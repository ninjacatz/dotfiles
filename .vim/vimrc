" ---------------------------
" BASIC FUNCTIONALITY
" ---------------------------
" disable vi compatibility mode
set nocompatible
" updatetime for various operations:
" cursor hold
" writes to swapfiles
" plugin triggers (if any)
set updatetime=250
" enable mouse in all modes
set mouse=a
" use the system clipboard
set clipboard=unnamedplus
" enable swapfiles, store them with full path names
set swapfile directory=~/.vim/swap//
" viminfo path and number of entries
set viminfo+=n~/.vim/viminfo history=1000
" encoding and file format
set encoding=utf-8 fileformat=unix
" enable filetype detection
filetype on
" auto change working directory to current file directory
set autochdir
" reload files changed outside of vim
set autoread
" case-insensitive search unless using upper case letters
set ignorecase smartcase
" backspace behavior:
" start=goes to previous line when at start of line
" eol=goes to end of previous line when at start of line
" indent=deletes any auto-indentation
set backspace=start,eol,indent
" include extra characters when changing words
set iskeyword+=-
" autoindent new lines
set autoindent
" keep cursor column when moving lines
set nostartofline
" use single space when joining lines
set nojoinspaces
" use tab character instead of spaces
set noexpandtab
" set tab length in all modes
set tabstop=4 softtabstop=4 shiftwidth=4
" can switch away from unsaved buffers
set hidden
" switch to the most recently used buffer
set switchbuf=uselast
" search as you type and highlight matches
set incsearch hlsearch
" vertical and horizontal split settings
set splitbelow splitright
" set grep command
set grepprg=grep\ -irnHI
" prevent netrw from loading
let g:loaded_netrw=1
let g:loaded_netrwPlugin=1
" TODO: when opening a directory, cd to it and open a blank buffer (replaces netrw)
autocmd BufEnter * if &buftype == '' && isdirectory(expand('%:p')) | execute 'cd ' . expand('%:p') | enew | execute 'bd #' | endif
" TODO: use bash login shell (not sourcing bashrc with sudo or root)
set shell=/bin/bash shellcmdflag=-lc
" set $PATH to system $PATH when sudo or root
if $USER == "root" || $HOME == "/root"
	let $PATH = trim(system('echo $PATH'))
endif

" ---------------------------
" STATUS LINE
" ---------------------------
" FUNCTIONS
" get path formatted by autochdir with tilde substitution
function! StatusLineAutochdirPath()
	let path = &autochdir ? expand("%:p:~:h") : fnamemodify(getcwd(-1), ':~')
	return &autochdir ? path . '/' : '[' . path . '] '
endfunction
" get filetype with formatting or empty string
function! StatusLineFileType()
	 return !empty(&filetype) ? '[' . &filetype . '] ' : ''
endfunction

" always show status bar
set laststatus=2

" begin statusline
set statusline=
" display if root or sudo
if $USER == "root" || $HOME == "/root"
	if $HOME == '/root'
		set statusline+=(root)\ 
	else
		set statusline+=(sudo)\ 
	endif
endif
" display if ssh connection
if !empty($SSH_CONNECTION)
	set statusline+=(ssh)\ 
endif
" finish statusline
set statusline+=%{StatusLineAutochdirPath()}%f\ %m%r%w%=%{StatusLineFileType()}%L

" ---------------------------
" VISUAL TWEAKS
" ---------------------------
" remove intro message
set shortmess+=I
" disables audio/visual bells
set belloff=all
" set true color support
set termguicolors
" enable syntax highlighting
syntax on
" enable and define whitespace characters
set list listchars=tab:»·,extends:>,precedes:<,space:·
" set sign column
set signcolumn=yes
" set line numbers and relative line numbers
set number relativenumber
" highlight current line
set cursorline
" number of lines to keep  at top or bottom while scrolling
set scrolloff=8
" enable word wrap and preserve word wrap indentation
set wrap breakindent
" highlight matching brackets, quotes, etc.
set showmatch
" show commands in command line as they are being typed
set showcmd
" show tabline at top if multiple tabs open
set showtabline=1
" set cursor to line in insert mode, or block otherwise
autocmd InsertEnter * silent execute "!echo -ne '\e[5 q'"
autocmd InsertLeave * silent execute "!echo -ne '\e[2 q'"
" TODO: (where to put?) disable auto-comment on new line
autocmd FileType * set formatoptions-=c formatoptions-=r formatoptions-=o

" ---------------------------
" COLORSCHEME
" ---------------------------
" TODO: colorscheme light/dark based on terminal window class
let window_class = system("xprop -id $(xdotool getactivewindow) | awk -F '\"' '/WM_CLASS/ {print $2}'")
if trim(window_class) == "vim"
	set background=light
else
	set background=dark
endif
" colorscheme
colorscheme gruvbox8
" turn off background (for terminal transparency)
hi Normal guibg=NONE ctermbg=NONE

" ---------------------------
" AUTO-COMPLETE
" ---------------------------
" use default language-specific completions with omni complete
set omnifunc=syntaxcomplete#Complete
" set menu to show even if there is only one entry
set completeopt=menuone
" turn off completion messages in command line
set shortmess+=c

" ---------------------------
" AUTO-COMPLETE (COMMAND LINE)
" ---------------------------
" turn on completions (and ignore case)
set wildmenu wildignorecase
" complete full match, display full list
set wildmode=full
" display pop up menu
set wildoptions=pum

" ---------------------------
" AUTO INSTALL vim-plug
" ---------------------------
" install with the command: vim +PlugInstall +qa
let data_dir = '~/.vim'
if empty(glob(data_dir . '/autoload/plug.vim'))
	silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
	autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" ---------------------------
" INSTALL PLUGINS
" ---------------------------
" remember: :PlugStatus, :PlugUpdate, :PlugClean, :PlugUpgrade
call plug#begin()
" auto-commenter
Plug 'preservim/nerdcommenter'
" completion manager (adds tab completion)
" by default, mucomplete tries completions in this order:
" path, omni, keyword, dictionary, spelling
Plug 'lifepillar/vim-mucomplete'
" linters, fixers, and lsp
Plug 'dense-analysis/ale'
" git integration
Plug 'airblade/vim-gitgutter'
" claude with api
Plug 'pasky/claude.vim'
call plug#end()

" ---------------------------
" CONFIGURE PLUGINS
" ---------------------------
" PLUGIN: nerdcommenter
" get rid of default mappings
let g:NERDCreateDefaultMappings=0
" create space around comments
let NERDSpaceDelims=1

" PLUGIN: ale
" disable error text at end of line
let g:ale_virtualtext_cursor=0
" fixers
let g:ale_fix_on_save=1
let g:ale_fixers = {
\	'*': ['remove_trailing_lines'],
\}
" linters
let g:ale_lint_on_text_changed='never'
let g:ale_lint_on_save=1
let g:ale_linters_explicit=1
let g:ale_linters = {
\	'sh': ['shellcheck'],
\	'python': ['flake8'],
\	'c': ['gcc'],
\}
" linter errors to ignore
let g:ale_python_flake8_options='--ignore=E501,E302,E261'

" PLUGIN: vim-gitgutter
let g:gitgutter_update_interval=1000
" disable all keymaps
let g:gitgutter_map_keys=0
" will not overwrite ale signs in gutter
let g:gitgutter_sign_allow_clobber=0

" PLUGIN: claude.vim
" disable default keymaps
let g:claude_map_open_chat = ""
let g:claude_map_implement = ""
let g:claude_map_send_chat_message = ""
let g:claude_map_cancel_response = ""
" set model
let g:claude_model = 'claude-sonnet-4-20250514'
" set api key if it exists
if filereadable(expand('~/.vim/claude-api.key'))
	let g:claude_api_key=trim(readfile(expand('~/.vim/claude-api.key'))[0])
endif

" ---------------------------
" KEYMAPS
" ---------------------------
" set keymap timeout delay
set timeoutlen=2000
" set key code timeout delay
set ttimeoutlen=0
" clear highlights on pressing <Esc>
nnoremap <Esc> :nohlsearch<CR>
" use <CR> to select item in auto-complete menu
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "<CR>"
" auto-completing brackets, quotes, etc
inoremap "<CR> ""<Left>
inoremap '<CR> ''<Left>
inoremap (<CR> ()<Left>
inoremap [<CR> []<Left>
inoremap <<CR> <><Left>
inoremap {<CR> {<CR>}<ESC>O

" ---------------------------
" KEYMAPS (MAP LEADER)
" ---------------------------
" FUNCTIONS
" automatically set tab length in all modes with one number
function! SetTabLength()
	let l = input('Enter tab length: ')
	if l =~ '^\d\+$'
		let l = str2nr(l)
		execute 'set tabstop=' . l
		execute 'set softtabstop=' . l
		execute 'set shiftwidth=' . l
	else
		echo 'Invalid tab length. Positive integers only'
	endif
endfunction
" searching with grep and selecting with copen
function! GrepCopen()
	let pattern = input(':grep ')
	if pattern == ''
		return
	endif
	let quoted_pattern = shellescape(pattern)
	silent execute 'grep ' . quoted_pattern
	copen
	redraw!
endfunction
" renaming a file in place
function! RenameFile()
	let old_name = expand('%:t')
	let old_file_path = expand('%:p')
	let old_path = expand('%:p:h')
	if &modified
		echoerr 'Cannot rename unsaved file'
		return
	endif
	if !filereadable(old_file_path)
		echoerr 'Current buffer is not readable file'
		return
	endif
	let new_name = input('Rename ' . old_name . ' to ')
	if new_name == ''
		echoerr 'No new file name provided'
		return
	endif
	let new_file_path = old_path . '/' . new_name
	if filereadable(new_file_path) || isdirectory(new_file_path)
		echoerr "New file name already exists"
		return
	endif
	try
		call rename(old_file_path, new_file_path)
	catch /./
		echoerr "Failed to rename file"
		return
	endtry
	execute 'e' fnameescape(new_file_path)
	execute 'bd' fnameescape(old_file_path)
endfunction

" set leader key
let mapleader=' '

" 1 -> 9
" nnoremap <Leader>`
" nnoremap <Leader>1
" nnoremap <Leader>2
" nnoremap <Leader>3
" nnoremap <Leader>4
" nnoremap <Leader>5
" nnoremap <Leader>6
" nnoremap <Leader>7
" nnoremap <Leader>8
nnoremap <Leader>9 10<C-w><
nnoremap <Leader>0 10<C-w>>
nnoremap <Leader>- 3<C-w>-
nnoremap <Leader>= 3<C-w>+
nnoremap <Leader><BS> :so $HOME/.vim/vimrc<CR>
"
" q -> p
nnoremap <Leader><Tab> :set tabstop? softtabstop? shiftwidth? expandtab?<CR>
nnoremap <Leader><S-Tab> :call SetTabLength()<CR>
nnoremap <Leader>q :q<CR>
nnoremap <Leader>Q :q!<CR>
nnoremap <Leader>w :w<CR>
nnoremap <Leader>W :w!<CR>
nnoremap <Leader>e :ALEDetail<CR>
nnoremap <Leader>r :call RenameFile()<CR>
nnoremap <Leader>t :silent execute '!nohup alacritty --config-file $HOME/.config/alacritty/term.yml --working-directory %:p:h > /dev/null 2>&1 &' <Bar> redraw!<CR>
nnoremap <Leader>y :browse oldfiles<CR>
nnoremap <Leader>Y :browse history<CR>
nnoremap <Leader>u :changes<CR>
nnoremap <Leader>i :help<Space>
nnoremap <Leader>o :split<CR>
nnoremap <Leader>O :vsplit<CR>
noremap <Leader>p "0p
nnoremap <Leader>[ :cd %:p:h<CR>:set noautochdir<CR>
nnoremap <Leader>] :set autochdir<CR>
nnoremap <Leader>\ :ClaudeCancel<CR>

" a -> l
nnoremap <Leader>a :ClaudeChat<CR>
vnoremap <Leader>a :ClaudeImplement<Space>
nnoremap <Leader>s :set spell<CR>
nnoremap <Leader>S :set nospell<CR>
nnoremap <Leader>d :bd<CR>
nnoremap <Leader>D :bd!<CR>
nnoremap <Leader>f :silent execute '!nohup alacritty --config-file $HOME/.config/alacritty/vifm.yml -e vifm %:p:h > /dev/null 2>&1 &' <Bar> redraw!<CR>
nnoremap <Leader>g :GitGutterDiffOrig<CR>
nnoremap <Leader>h <C-w><C-h>
nnoremap <C-h> :tabprevious<CR>
nnoremap <Leader>j <C-w><C-j>
nnoremap <C-j> :bn<CR>
nnoremap <Leader>k <C-w><C-k>
nnoremap <C-k> :bp<CR>
nnoremap <Leader>l <C-w><C-l>
nnoremap <C-l> :tabNext<CR>
nnoremap <Leader>; :!
nnoremap <Leader>: :sh<CR>
nnoremap <Leader>' :marks<CR>:mark<Space>
nnoremap <Leader>" :registers<CR>
nnoremap <Leader><CR> :ClaudeSend<CR>

" z -> m
nnoremap <Leader>z :args `find . -type f -size -$((256*256))c -name '*'`<Left><Left>
nnoremap <Leader>x :tabc<CR>
nnoremap <Leader>X :tabc!<CR>
noremap <Leader>c :call nerdcommenter#Comment(0,"toggle")<CR>
nnoremap <Leader>v :tabs<CR>:tabn<Space>
nnoremap <Leader>b :ls<CR>:b<Space>
nnoremap <Leader>n :e<Space>
nnoremap <Leader>N :e **/*
nnoremap <Leader>m :tabnew<Space>
nnoremap <Leader>M :tabnew **/*
xnoremap <Leader>, :norm<Space>
nnoremap <Leader>. :%s///g<Left><Left><Left>
xnoremap <Leader>. :s///g<Left><Left><Left>
nnoremap <Leader>> :bufdo %s///gc <Bar> update<Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left><Left>
nnoremap <Leader>/ :call GrepCopen()<CR>

" other keys
nnoremap <Leader><Space> :map<CR>
